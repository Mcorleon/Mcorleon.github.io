<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Mcorleon">
  <!-- Open Graph Data -->
  <meta property="og:title" content="数据结构与算法">
  <meta property="og:description" content="java">
  <meta property="og:site_name" content="923号森林">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://Mcorleon.github.io">
  
    <link rel="alternate" href="/atom.xml" title="923号森林" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/logo.png">
  

  <!-- Site Title -->
  <title>923号森林</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  



</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">数据结构与算法</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  主页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/Mcorleon">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:mcorleon95@outlook.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>

</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Mcorleon</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-05-29</span>
            <span class="time">15:09:44</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/算法/">算法</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Algorithm/">#Algorithm</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>常见数据结、算法问题的java实现</p>
<a id="more"></a>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 找到倒数第N个节点</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">Listnode <span class="title">NthNodeFromEnd</span><span class="params">(Listnode headNode, <span class="keyword">int</span> NthNode)</span> </span>&#123;</span><br><span class="line">        Listnode pTemp = headNode, pNthNode = headNode;</span><br><span class="line">        <span class="keyword">if</span> (headNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//        pTemp后移N次，pNthNode再开始</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; NthNode) &#123;</span><br><span class="line">            pTemp = pTemp.getNext();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        pTemp 和pNthnode同时后移，直到pTemp到表尾</span></span><br><span class="line">        <span class="keyword">while</span> (pTemp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pTemp = pTemp.getNext();</span><br><span class="line">            pNthNode = pNthNode.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNthNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Floyd环判定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表是否存在环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">doesLinkedListCotainLoop</span><span class="params">(Listnode headNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        快指针每次走2步，慢指针走1步，会相遇就有环</span></span><br><span class="line">        Listnode slowPtr=headNode,fastPtr=headNode;</span><br><span class="line"><span class="comment">//        这样判定是因为快指针每次走2步</span></span><br><span class="line">        <span class="keyword">while</span> (fastPtr.getNext()!=<span class="keyword">null</span>&amp;&amp;fastPtr.getNext().getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slowPtr=slowPtr.getNext();</span><br><span class="line">            fastPtr=fastPtr.getNext().getNext();</span><br><span class="line">            <span class="keyword">if</span>(slowPtr==fastPtr)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *找到环的起点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Listnode <span class="title">findBeginLoop</span><span class="params">(Listnode headNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        Boolean loopExists=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        快指针每次走2步，慢指针走1步，会相遇就有环</span></span><br><span class="line">        Listnode slowPtr=headNode,fastPtr=headNode;</span><br><span class="line">        <span class="keyword">while</span> (fastPtr.getNext()!=<span class="keyword">null</span>&amp;&amp;fastPtr.getNext().getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slowPtr=slowPtr.getNext();</span><br><span class="line">            fastPtr=fastPtr.getNext().getNext();</span><br><span class="line">            <span class="keyword">if</span>(slowPtr==fastPtr)&#123;</span><br><span class="line">                loopExists=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loopExists==<span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        相遇后，慢指针指向重新指向头节点，各自开始每次走1步，相遇处就是环的起点</span></span><br><span class="line">        slowPtr=headNode;</span><br><span class="line">        <span class="keyword">while</span> (slowPtr!=fastPtr)&#123;</span><br><span class="line">            slowPtr=slowPtr.getNext();</span><br><span class="line">            fastPtr=fastPtr.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算环的长度</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLoopLength</span><span class="params">(Listnode headNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        快指针每次走2步，慢指针走1步，会相遇就有环</span></span><br><span class="line">        Boolean loopExists=<span class="keyword">false</span>;</span><br><span class="line">        Listnode slowPtr=headNode,fastPtr=headNode;</span><br><span class="line">        <span class="keyword">while</span> (fastPtr.getNext()!=<span class="keyword">null</span>&amp;&amp;fastPtr.getNext().getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slowPtr=slowPtr.getNext();</span><br><span class="line">            fastPtr=fastPtr.getNext().getNext();</span><br><span class="line">            <span class="keyword">if</span>(slowPtr==fastPtr)&#123;</span><br><span class="line">                loopExists=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        相遇后慢指针不动,快指针每次走1步，重新相遇就是环的长度。</span></span><br><span class="line">        <span class="keyword">if</span> (loopExists)&#123;</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            fastPtr=fastPtr.getNext();</span><br><span class="line">            <span class="keyword">while</span> (fastPtr!=slowPtr)&#123;</span><br><span class="line">                fastPtr=fastPtr.getNext();</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆置链表</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">Listnode <span class="title">ReverseList</span><span class="params">(Listnode headNode)</span></span>&#123;</span><br><span class="line">    Listnode temp=<span class="keyword">null</span>,nextNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (headNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        nextNode=headNode.getNext();</span><br><span class="line">        headNode.setNext(temp);</span><br><span class="line">        temp=headNode;</span><br><span class="line">        headNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到链表中间节点</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">Listnode <span class="title">FindMidNode</span><span class="params">(Listnode headNode)</span></span>&#123;</span><br><span class="line">        Listnode fastPtr=headNode,slowPtr=headNode;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        快指针每走2步慢指针走1步，快指针走完，慢指针就到中间</span></span><br><span class="line">        <span class="keyword">while</span>(fastPtr.getNext()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                fastPtr=fastPtr.getNext();</span><br><span class="line">                i=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                fastPtr=fastPtr.getNext();</span><br><span class="line">                slowPtr=slowPtr.getNext();</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  slowPtr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个有序链表合成新的有序链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Listnode <span class="title">MergeList</span><span class="params">(Listnode a,Listnode b)</span></span>&#123;</span><br><span class="line">    Listnode result=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.getData()&lt;=b.getData())&#123;</span><br><span class="line">        result=a;</span><br><span class="line">        a.setNext(MergeList(a.getNext(),b));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result=b;</span><br><span class="line">        b.setNext(MergeList(b.getNext(),a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *两个栈实现队列</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//入队：压入s1。出队：s2不为空就弹出栈顶元素，为空就把s1全部压入s2，然后弹出栈顶。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack2.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *两个队列实现栈</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//入栈：随便进一个队，要保证另一个队是空的。出栈：把队中n-1个元素出队进到空队，剩下一个出队并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue1.isEmpty())&#123;</span><br><span class="line">        queue2.enQueue(node);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        queue1.enQueue(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(queue2.isEmpty())&#123;</span><br><span class="line">        size=queue1.getSize();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            queue2.enQueue(queue1.deQueue());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue1.deQueue();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        size=queue2.getSize();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            queue1.enQueue(queue2.deQueue());</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue2.deQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *前序遍历</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *中序遍历</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *后序遍历</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *层次遍历</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp=queue.poll();</span><br><span class="line">        System.out.println(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *递归法求二叉树高度（深度）</span></span><br><span class="line"><span class="comment"> *非递归用层次遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_h，right_h;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left_h=heightOfTree(root.left);</span><br><span class="line">        right_h=heightOfTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left_h&gt;right_h)&#123;</span><br><span class="line">            <span class="keyword">return</span> left_h+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> right_h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *根据前序遍历和中序遍历还原二叉树</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前序遍历第一个数是根节点</span></span><br><span class="line">        <span class="comment">//中序遍历根节点左边是左子树，右边是右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span>||in.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==root.val)&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, 			i+<span class="number">1</span>),Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right=reConstructBinaryTree(Arrays.copyOfRange(pre, i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *判断B是否为A的子树</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> res=<span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">                res=isSubtree(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res=HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res=HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//root2遍历完了都对的上</span></span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root1先遍历完 false</span></span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(root1.left,root2.left)&amp;&amp;isSubtree(root1.right,root2.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *二叉树镜像</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    TreeNode temp=root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *求二叉树所有根节点到叶子的路径</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindPaths</span><span class="params">(TreeNode root,ArrayList res,ArrayList path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//叶子</span></span><br><span class="line">        res.add(path);</span><br><span class="line">        path.removeAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ArrayList path2=<span class="keyword">new</span> ArrayList();</span><br><span class="line">        path2.addAll(path);</span><br><span class="line">        FindPaths(root.left,res,path);</span><br><span class="line">        FindPaths(root.right,res,path2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *求二叉树所有和为target的路径</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">judgePath</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; path,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//是叶子</span></span><br><span class="line">            <span class="keyword">if</span>(root.val==target)&#123;</span><br><span class="line">                res.add(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//不是叶子</span></span><br><span class="line">            ArrayList&lt;Integer&gt; path2=<span class="keyword">new</span> ArrayList();</span><br><span class="line">            path2.addAll(path);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                judgePath(root.left,path,target-root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                judgePath(root.right,path2,target-root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>二叉搜索树的中序遍历就是从小到大排序</p>
<p>二叉搜索树的后续遍历最后一个元素是root，前半部分小于root，后半部分大于root，且每个部分也满足此规律</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *判断是否为平衡树</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> depth=TreeDepth(root);</span><br><span class="line">    <span class="keyword">return</span> depth&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=<span class="number">0</span>,rightDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth=TreeDepth(root.left);</span><br><span class="line">    rightDepth=TreeDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span>(leftDepth&gt;=<span class="number">0</span>&amp;&amp;rightDepth&gt;=<span class="number">0</span>&amp;&amp;Math.abs(rightDepth-leftDepth)&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftDepth&gt;rightDepth)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *求两个节点的最近共同祖先</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLCA</span><span class="params">(TreeNode root,TreeNode a,TreeNode b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root==a||root==b)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left,right;</span><br><span class="line">    left=getLCA(root.left,a,b);</span><br><span class="line">    right=getLCA(root.right,a,b);</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left==<span class="keyword">null</span>?right:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java里的堆用优先队列实现，默认是小顶堆。大顶堆如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(DEFAULT_INITIAL_CAPACITY, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;                </span><br><span class="line">            <span class="keyword">return</span> o2-o1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>堆化：大顶堆的堆化就是将不符合要求的节点与最大的子节点交换，重复这个过程直到满足性质，也叫向下渗透</p>
<p>插入：在堆尾插入元素，然后向上渗透</p>
<h5 id="大文件找最大10个元素的算法："><a href="#大文件找最大10个元素的算法：" class="headerlink" title="大文件找最大10个元素的算法："></a>大文件找最大10个元素的算法：</h5><p>分成1000,990,990…..的堆，先从1000的块中找最大的10个元素加入990的块，以此类推。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;<span class="number">0</span> ;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 和冒泡不同之处在于：冒泡每一轮比较相邻的，一轮结束后最大值被换到最后。</span></span><br><span class="line"><span class="comment"> * 选择排序是用当前值逐一与后面的比较，交换，选出最小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;array.length ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[i];</span><br><span class="line">                array[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * 接近有序时效率最高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span> ;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&gt;<span class="number">0</span> ;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&lt;array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                temp=array[j];</span><br><span class="line">                array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//前面都是从小到大排好的，符合就不必继续比较了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡、选择、插入的平均和最坏复杂度都是O（n^2^），空间都是O（1），其中选择排序不稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] temp,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,temp,left,mid);</span><br><span class="line">        mergeSort(array,temp,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(array,temp,left,mid+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span>[] temp,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_end=mid-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp_pos=left;</span><br><span class="line">    <span class="keyword">int</span> size=right-left+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左右两组都是已排序的，再排序整合成新的一组</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=left_end&amp;&amp;mid&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[left]&lt;array[mid])&#123;</span><br><span class="line">            temp[temp_pos++]=array[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp[temp_pos++]=array[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下两个while只有一个会执行，目的是把那一组剩下的元素全部加到temp后面去</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=left_end)&#123;</span><br><span class="line">        temp[temp_pos++]=array[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mid&lt;=right)&#123;</span><br><span class="line">        temp[temp_pos++]=array[mid++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把排好的temp写回原数组去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size ;i++)&#123;</span><br><span class="line">        array[right]=temp[right];</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均和最坏时间都是O（nlog n），空间：临时数组O（n）+递归深度O（log n）=O（n），稳定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 越接近无序效率越高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        pivot=partition(array,left,right);</span><br><span class="line">        quickSort(array,left,pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(array,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//基准值默认是第一个坑位</span></span><br><span class="line">    <span class="keyword">int</span> pivot_val=array[left];</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//从右往左找小于基准值的值</span></span><br><span class="line">        <span class="keyword">while</span> (array[right]&gt;pivot_val&amp;&amp;left&lt;right)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了，填上左边的坑，右边出新坑</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            array[left]=array[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左往右找大于基准值的值（两个while需要有一个有=号）</span></span><br><span class="line">        <span class="keyword">while</span> (array[left]&lt;=pivot_val&amp;&amp;left&lt;right)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了，填上右边的坑，左边又出现坑</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            array[right]=array[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这时left=right，退出循环。最后这个坑的位置就是枢轴，这里左边都小于pivot_val右边都大于pivot_val</span></span><br><span class="line">    array[left]=pivot_val;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均O（nlog n）最坏O（n^2^），空间O（log n~n），最坏情况下退化成冒泡，不稳定</p>
<p>大O复杂度表示的是随着数据规模的增大算法时间代价增长的趋势，和实际执行时间无关，所以相比于归并排序快速排序虽然最坏情况复杂度大，但是平均执行时间快于归并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//堆是满二叉树，n/2+1~n的元素都是叶子节点,根据前面n/2个元素进行向下渗透构建即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//构建成大顶锥</span></span><br><span class="line">        heapAdjust(array,i,array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//把最大的元素换到最后</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        <span class="comment">//重新调整为大顶堆</span></span><br><span class="line">        heapAdjust(array,<span class="number">1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> s,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">     <span class="comment">//节点s表示为a[s-1]，左右孩子应为a[2s-1],a[2s]</span></span><br><span class="line">    <span class="keyword">int</span> temp= a[s-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//largest中存关键字较大的记录下标</span></span><br><span class="line">    <span class="keyword">int</span> largest=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*s;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//取较大孩子的下标</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; a[i-<span class="number">1</span>]&lt;a[i])&#123;</span><br><span class="line">            largest = i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            largest = i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否继续向下渗透</span></span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=a[largest])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            a[s-<span class="number">1</span>] = a[largest];</span><br><span class="line">            s = largest+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[s-<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平均和最坏都是O（nlog n），空间O（1），不稳定</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找（对已排序数组）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySerch</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q</strong>：40亿整数里找一个数是否存在？</p>
<p><strong>A</strong>：32位整数如果用set存储需要16GB内存，一般无法满足。分多次加载的话磁盘io太费时，不推荐。推荐的做法：分布式环境的话可以使用mapReduce来做，map函数统计从机各自的块里是否有这个数，reduce函数汇总结果。单机环境用bitmap来做，申请2^32^个位（能够表示整个整数范围，大概42亿），然后扫描所有数字，存在置1，不存在置0。还有一种方法：将连续的数字构成新的结构体，如2,3,4,5,6用（2,5）表示，40亿数在42亿范围内最多有2亿的断点，断点外的数字就是存在的，一个结构体8字节，使用1.6GB内存。</p>
<p><strong>Q</strong>:O(1)删除链表节点</p>
<p><strong>A</strong>：复制该节点的next给它：node.value=node.next.vaule; node.next=node.next.next </p>
<p><strong>Q</strong>:识别2^n^</p>
<p><strong>A</strong>：n&amp;(n-1)可以消除二进制最右边的1，2^n^做这个运算后为0</p>
<p><strong>Q</strong>:TopK问题，例如100亿个数找最大的1000个</p>
<p><strong>A</strong>：1.维护容量1000的小顶堆，每次与堆顶最小的数比，大于就替换它再重新堆化，小于就跳过。复杂度O((N-M)logM)，时间换空间</p>
<p>2.分治法，分1000个大区，每个大区100个小区，小区用小顶堆法取前1000个数，然后合并小区，最后合并大区。可以用多线程执行，类似MapReduce。</p>
<p><strong>Q</strong>：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字</p>
<p><strong>A</strong>：一个数和自己异或等于0；一个数和0异或还是本身。把数组所有数字异或，得到的结果就是num1^num2</p>
<p>从最低位开始找第一个1，把数组分成这个位是1和是0的两组，两组分别异或就得到了这两个数字</p>
<p><strong>位运算技巧</strong></p>
<p>n乘以2^m^ :   n&lt;&lt;m</p>
<p>n除以2^m^ :   n&gt;&gt;m</p>
<p>判断奇偶数：n&amp;1  1为奇数0为偶数</p>
<p>m对2^n^取余(消除二进制最右边的1)：m&amp;(n-1)</p>
<p><strong>Q</strong>：大数据排序（10GB数据，512M内存排序）</p>
<p><strong>A</strong>：无重复数字：可用bitmap，申请32位覆盖整个整数范围，使用内存2^32^bit=512M（刚好把内存用完，其实不行，要留内存给程序执行）。io读数据，存在的数据就记入bitmap，最后扫描bitmap，按顺序io写回去就是排序好的。</p>
<p>有重复数字：分治法。分成多个小文件先内部排序，最后两两归并。（使用io资源较多）</p>
<p><strong>Q</strong>：敏感词过滤（文件查找是否包含某些单词）</p>
<p><strong>A</strong>：构建敏感词库（字典树）：对每个敏感词里的字都new一个TrieNode，存入所有能和它匹配的下一个字的TrieNode和一个isEnd标记。</p>
<p>比如这就是一个字典树：{五={星={红={isEnd=0, 旗={isEnd=1}}, isEnd=0}, isEnd=0}, 中={isEnd=0, 国={isEnd=0, 人={isEnd=1}, 男={isEnd=0, 人={isEnd=1}}}}}</p>
<p>匹配时：map=hashMap.get(“某个字”)，map是null 那就不是敏感词；如果找到了就判断isEnd，是1就是敏感词，是0就继续判断某个字的下一个字在不在map里。</p>
<p><strong>Q</strong>：100G文件找到出现次数最多的IP地址</p>
<p><strong>A</strong>：哈希分桶，每个IP地址映射到相应文件中：file_id = hash(ip) % 1000 ，相同的IP一定会被分到同一个文件里去，最后统计并汇总即可</p>
<p><strong>Q</strong>：100亿整数找到只出现一次的数</p>
<p><strong>A</strong>：用bitmap 每个数分配2个bit 00没出现 01出现一次 10出现多次 11舍去，需要2x2^32^bit=1GB内存。内存不足的话改用哈希分桶再汇总的方法。</p>
<p><strong>Q</strong>：两个文件，各100亿个整数，求交集</p>
<p><strong>A</strong>：二者的bitmap相与</p>
<p><strong>Q</strong>：100亿整数求中位数</p>
<p><strong>A</strong>：哈希分桶。最高位0和1的分到2个文件，比如70亿个在file_0,30亿个在file_1，那中位数就是file_0排序后第20亿个数，file_1就不用考虑了。对file_0再分桶，次高位为0和1的再分成file_0_0 ,file_0_1,后者比前者大，比如file_0_0 60亿 file_0_1 10亿，那中位数就是file_0_0排序后第10亿个数，同理继续分桶..分到足够小就可以快排或者归并得到答案。</p>
<p><strong>Q</strong>：判断点是否在多边形内部</p>
<p><strong>A</strong>：点向右边做作射线，奇数个交点就在内部。具体编程实现：得到每条边的方程，把pt.y带入，得到x，x&gt;pt.x的话点就在边的左边，会穿过边。</p>
<p><strong>Q</strong>：手机号压缩存储</p>
<p><strong>A</strong>：1个int+1个byte，5个字节可存一个手机号    </p>

<!-- Link Gitalk 的支持文件  -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
<script src="https://cdn.bootcss.com/blueimp-md5/2.8.0/js/md5.min.js"></script>
<div id="gitalk-container"></div>     <script type="text/javascript">
    var gitalk = new Gitalk({

    // gitalk的主要参数
        clientID: '4bad4efde948931a3829',
        clientSecret: 'acdd4548be531ef7495346a44c8b8a7572ccd5ff',
        repo: 'mcorleon.github.io',
        owner: 'Mcorleon',
        admin: ['Mcorleon'],
        id: md5(location.pathname),

    });
    gitalk.render('gitalk-container');
</script> 
        </div>
      </div>
    </div>
  </div>

<!-- Gitalk end -->
</article>




    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
         Hey Jude,we will ride them someday.
    
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

